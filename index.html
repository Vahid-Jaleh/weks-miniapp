<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WEKS Tap-To-Math</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: Arial, sans-serif; background:#111; color:#fff; margin:0; padding:24px; text-align:center; }

    /* smaller title */
    h1 { margin: 0 0 8px; display:flex; align-items:center; gap:10px; justify-content:center; font-size:20px; line-height:1.2; }
    .logo { width:28px; height:28px; border-radius:6px; background:#ffd54a; display:inline-block; }

    .balance { font-size:18px; margin:4px 0 10px; position:relative; }
    .sub { opacity:.85; margin-bottom:14px; }

    /* actions row (kept layout) */
    .actions { display:flex; gap:8px; justify-content:center; margin:6px 0 10px; }
    .ico-btn {
      display:inline-flex; align-items:center; gap:6px;
      padding:8px 10px; border:0; border-radius:10px; font-size:13px; cursor:pointer; color:#111;
      background: linear-gradient(180deg,#ffe16f,#ffc22a);
      box-shadow: 0 4px 14px rgba(255,194,42,.35);
    }
    .ico-btn:active { transform: translateY(1px); }
    .ico { font-size:16px; }

    /* Progress bar */
    .bar-wrap { margin: 0 auto 16px; max-width:420px; background:#1c1c1c; border-radius:12px; padding:8px 10px; box-shadow:0 4px 14px rgba(0,0,0,.35); }
    .bar-label { display:flex; justify-content:space-between; font-size:13px; opacity:.9; margin-bottom:6px; }
    .bar { position:relative; width:100%; height:12px; background:#2a2a2a; border-radius:999px; overflow:hidden; }
    .fill { position:absolute; left:0; top:0; bottom:0; width:0%; border-radius:999px;
      background: linear-gradient(90deg,#ffe16f,#ffc22a);
      box-shadow: inset 0 0 6px rgba(0,0,0,.35), 0 0 10px rgba(255,194,42,.45);
      transition: width .35s ease; }

    .card { margin:0 auto; max-width:420px; background:#1c1c1c; padding:20px; border-radius:14px; box-shadow:0 6px 22px rgba(0,0,0,.5); }
    .q { font-size:34px; margin:18px 0; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }

    /* Gold sheen buttons */
    .btn { padding:14px 10px; border:0; border-radius:12px; font-size:18px; cursor:pointer; color:#111;
      background: linear-gradient(180deg,#ffe16f,#ffc22a);
      box-shadow: 0 6px 20px rgba(255,194,42,.35);
      position:relative; overflow:hidden;
    }
    .btn:active { transform: translateY(1px); }
    .btn::after{
      content:""; position:absolute; top:-100%; left:-50%; width:80%; height:300%;
      background: linear-gradient(120deg, rgba(255,255,255,.0) 0%, rgba(255,255,255,.4) 50%, rgba(255,255,255,.0) 100%);
      transform: rotate(20deg); animation: sheen 3s infinite;
    }
    @keyframes sheen{ 0%{left:-80%} 60%{left:120%} 100%{left:120%} }

    .meta { margin:14px 0 4px; font-size:14px; opacity:.85; }
    .ok { color:#6ee78c; }
    .bad { color:#ff7a7a; }
    .muted { opacity:.7; }
    .claim { margin:18px auto 0; width:100%; max-width:420px; display:block; }

    /* Bigger flying coin + pop */
    .coin {
      position:fixed; width:26px; height:26px; border-radius:50%;
      background:
        radial-gradient(circle at 30% 30%, #ffffff66, #ffffff00 60%),
        radial-gradient(circle at 55% 55%, #ffd84d, #ffc02a);
      box-shadow: 0 0 14px rgba(255,194,42,.75), 0 0 30px rgba(255,194,42,.25);
      pointer-events:none; z-index:9999; transform:translate(-50%,-50%);
      will-change: transform, opacity;
    }
    .pop {
      position:fixed; color:#ffe16f; font-weight:700; font-size:16px; pointer-events:none; z-index:9999;
      text-shadow: 0 2px 8px rgba(0,0,0,.6);
      transform:translate(-50%,-50%) scale(0.8); opacity:0;
      animation: popUp .8s ease forwards;
    }
    @keyframes popUp { 0%{transform:translate(-50%,-50%) scale(.8); opacity:0;} 15%{opacity:1;} 100%{transform:translate(-50%,-120%) scale(1.15); opacity:0;} }

    /* üëç thumbs-up animation */
    .thumb {
      position:fixed; font-size:28px; pointer-events:none; z-index:9999;
      text-shadow: 0 2px 8px rgba(0,0,0,.5);
      transform:translate(-50%,-50%) scale(.7) rotate(-8deg); opacity:0;
      animation: thumbUp .9s ease-out forwards;
    }
    @keyframes thumbUp { 0%{transform:translate(-50%,-20%) scale(.7) rotate(-8deg); opacity:0;} 15%{opacity:1;} 100%{transform:translate(-50%,-140%) scale(1.1) rotate(6deg); opacity:0;} }

    /* Mute toggle (fixed, not changing layout) */
    .mute-toggle {
      position: fixed; right: 14px; bottom: 14px; z-index: 10000;
      width: 46px; height: 46px; border: 0; border-radius: 50%;
      display:flex; align-items:center; justify-content:center;
      background: #1c1c1c; color:#ffd54a; box-shadow: 0 6px 18px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,213,74,.25);
      cursor:pointer; font-size:20px;
    }
    .mute-toggle:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <h1><span class="logo"></span> WEKS <b>Tap-To-Math</b></h1>

  <div id="balance" class="balance" data-v="0">üí∞ Balance: ‚Ä¶</div>

  <!-- actions row -->
  <div class="actions">
    <button id="inviteBtn" class="ico-btn"><span class="ico">ü§ù</span><span>Invite Friend</span></button>
    <button id="leaderBtn" class="ico-btn"><span class="ico">üèÜ</span><span>Leaderboard</span></button>
  </div>

  <!-- Daily progress bar -->
  <div class="bar-wrap">
    <div class="bar-label">
      <span>Daily progress</span>
      <span id="remText">0 / 100</span>
    </div>
    <div class="bar">
      <div id="fill" class="fill"></div>
    </div>
  </div>

  <div class="sub">Solve, stack answers, then <b>Claim</b> to earn coins. You can keep practicing after the cap, but extra answers won‚Äôt add coins.</div>

  <div class="card">
    <div class="meta">Correct: <span id="c">0</span> ‚Ä¢ Wrong: <span id="w">0</span></div>
    <div id="q" class="q">Loading‚Ä¶</div>
    <div class="grid" id="answers"></div>
    <div id="flash" class="meta"></div>
  </div>

  <button id="claim" class="btn claim">CLAIM & CLOSE</button>

  <!-- mute toggle -->
  <button id="muteBtn" class="mute-toggle" aria-label="Toggle sound">üîä</button>

  <script>
    /* ---- Telegram WebApp safe shim ---- */
    const tg = (() => {
      const wa = window?.Telegram?.WebApp;
      if (wa) return wa;
      return {
        ready(){}, expand(){},
        MainButton: { hide(){} },
        HapticFeedback: { notificationOccurred(){} },
        showAlert: (m)=>alert(m),
        close(){},
        openTelegramLink: (u)=>window.open(u, '_blank'),
        openLink: (u)=>window.open(u, '_blank'),
        sendData: ()=>{}, // no-op outside Telegram
        initData: "",
        initDataUnsafe: {}
      };
    })();

    tg.ready(); 
    tg.expand?.();
    tg.MainButton?.hide?.();
    const alertBox = (m) => { try { tg.showAlert(m); } catch { alert(m); } };

    /* ---------- SOUND (Web Audio) + MUTE ---------- */
    let AC, masterGain, isMuted = false;
    try { isMuted = localStorage.getItem("weks_muted") === "1"; } catch {}

    function ctx() {
      if (!AC) {
        AC = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = AC.createGain();
        masterGain.gain.value = isMuted ? 0 : 1;
        masterGain.connect(AC.destination);
      }
      return AC;
    }
    function setMuted(m) {
      isMuted = m;
      if (masterGain) masterGain.gain.value = isMuted ? 0 : 1;
      try { localStorage.setItem("weks_muted", isMuted ? "1" : "0"); } catch {}
      document.getElementById('muteBtn').textContent = isMuted ? "üîá" : "üîä";
    }
    function ensureAudioStarted() { if (AC && AC.state === "suspended") { AC.resume?.(); } }

    // Applause + crowd cheer
    function applause(){
      const a = ctx();
      ensureAudioStarted();

      const echoDelay = a.createDelay(0.25);
      echoDelay.delayTime.value = 0.12;
      const echoGain = a.createGain(); echoGain.gain.value = 0.18;
      echoDelay.connect(echoGain).connect(masterGain);

      const mix = a.createGain(); mix.gain.value = 0.7;
      mix.connect(masterGain);
      mix.connect(echoDelay);

      const makeClap = (when=0, len=0.22, freq=1800, gmul=1.0) => {
        const src = a.createBufferSource();
        const buf = a.createBuffer(1, Math.floor(a.sampleRate*len), a.sampleRate);
        const d = buf.getChannelData(0);
        for (let i=0;i<d.length;i++){
          const t = i/a.sampleRate;
          d[i] = (Math.random()*2-1) * Math.pow(1 - t/len, 2.6);
        }
        src.buffer = buf;

        const bp = a.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq; bp.Q.value=0.9;
        const hp = a.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=260;
        const g  = a.createGain(); g.gain.value = 0.35 * gmul;
        src.connect(bp).connect(hp).connect(g).connect(mix);
        src.start(a.currentTime + when);

        const tap = a.createOscillator(); tap.type = 'square';
        tap.frequency.value = 2100 + Math.random()*300;
        const tapGain = a.createGain(); tapGain.gain.value = 0.22 * gmul;
        tap.connect(tapGain).connect(mix);
        tap.start(a.currentTime + when);
        tap.stop(a.currentTime + when + 0.03);
        tapGain.gain.setTargetAtTime(0.0001, a.currentTime + when + 0.01, 0.01);
      };
      makeClap(0.00, 0.20, 1800, 1.00);
      makeClap(0.07, 0.22, 1650, 0.9);
      makeClap(0.14, 0.20, 2050, 0.95);
      makeClap(0.24, 0.26, 1750, 1.1);
      makeClap(0.35, 0.22, 1900, 0.85);

      const whoop = a.createOscillator(); whoop.type = 'triangle';
      const whoopGain = a.createGain(); whoopGain.gain.value = 0.0;
      whoop.connect(whoopGain).connect(mix);
      const t0 = a.currentTime + 0.04;
      whoop.frequency.setValueAtTime(380, t0);
      whoop.frequency.exponentialRampToValueAtTime(760, t0 + 0.35);
      whoop.start(t0);
      whoop.stop(t0 + 0.5);
      whoopGain.gain.setValueAtTime(0.0, t0);
      whoopGain.gain.linearRampToValueAtTime(0.18, t0 + 0.12);
      whoopGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.5);

      const air = a.createBufferSource();
      const len = 0.45;
      const abuf = a.createBuffer(1, Math.floor(a.sampleRate*len), a.sampleRate);
      const ad = abuf.getChannelData(0);
      for (let i=0;i<ad.length;i++){
        const x = (Math.random()*2-1) * 0.6;
        const fade = i/ad.length;
        ad[i] = x * (1 - Math.pow(1-fade, 2.2));
      }
      air.buffer = abuf;
      const low = a.createBiquadFilter(); low.type = 'lowpass'; low.frequency.value = 1800;
      const airG = a.createGain(); airG.gain.value = 0.18;
      air.connect(low).connect(airG).connect(mix);
      air.start(t0 - 0.02);
    }

    function soundWrong(){
      const a = ctx(); ensureAudioStarted();
      const o = a.createOscillator(), g=a.createGain();
      o.type='sawtooth'; o.frequency.value=160; g.gain.value=0.14;
      o.connect(g).connect(masterGain); o.start();
      setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, a.currentTime+0.08); o.stop(a.currentTime+0.1); }, 220);
    }

    /* ---------- Persistent local progress ---------- */
    const STORAGE_KEY = "weks_progress_v1";
    const todayStr = () => new Date().toISOString().slice(0,10);
    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { day: todayStr(), correct: 0, wrong: 0 };
        const obj = JSON.parse(raw);
        if (obj.day !== todayStr()) return { day: todayStr(), correct: 0, wrong: 0 };
        return obj;
      } catch { return { day: todayStr(), correct: 0, wrong: 0 }; }
    }
    function saveProgress() { localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); }
    function resetProgressForToday() {
      progress = { day: todayStr(), correct: 0, wrong: 0 };
      saveProgress(); updateUI(); pendingBalance = 0; updateBalanceDisplay(true);
    }

    let progress = loadProgress();
    let current = null;

    /* ---------- Live balance (server + pending) ---------- */
    let serverBalance = 0;    // from server
    let pendingBalance = 0;   // local (10 per correct) ‚Äî CLAMPED
    let displayedBalance = 0; // last shown

    /* ---------- Server daily base ---------- */
    let serverTodayUsed = 0;
    const DAILY_CAP = 100;

    /* ---------- Helpers ---------- */
    const usedLocal = () => progress.correct + progress.wrong;
    const canEarnAnother = () => (serverTodayUsed + usedLocal()) < DAILY_CAP;

    /* ---------- Animated coin counter ---------- */
    function animateCoins(from, to, dur=600){
      const el = document.getElementById("balance");
      const start = performance.now();
      (function tick(t){
        const p = Math.min(1, (t-start)/dur);
        const eased = 1 - Math.pow(1-p, 3);
        const val = Math.round(from + (to-from)*eased);
        el.textContent = `üí∞ Balance: ${val}`;
        if(p<1) requestAnimationFrame(tick); else { displayedBalance = to; }
      })(start);
    }
    function updateBalanceDisplay(force=false){
      const next = serverBalance + pendingBalance;
      if(force){ displayedBalance = next; document.getElementById("balance").textContent = `üí∞ Balance: ${next}`; return; }
      animateCoins(displayedBalance, next);
    }

    /* ---------- UI ---------- */
    function updateUI(){
      document.getElementById("c").textContent = progress.correct;
      document.getElementById("w").textContent = progress.wrong;
      const used = Math.min(DAILY_CAP, serverTodayUsed + usedLocal());
      document.getElementById("fill").style.width = `${(used/DAILY_CAP)*100}%`;
      document.getElementById("remText").textContent = `${used} / ${DAILY_CAP}`;
    }
    function flash(text, good){
      const f = document.getElementById("flash");
      f.textContent = text;
      f.className = "meta " + (good===true?"ok":good===false?"bad":"");
    }

    /* ---------- Quiz ---------- */
    function randint(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function newQuestion(){
      const ops = ["+","-","√ó","√∑"];
      const op = ops[randint(0,ops.length-1)];
      let a = randint(2,25), b = randint(2,25), ans=0;
      if(op==="+"){ ans = a+b; }
      else if(op==="-"){ if(b>a){ [a,b]=[b,a]; } ans=a-b; }
      else if(op==="√ó"){ ans=a*b; }
      else if(op==="√∑"){ ans = randint(2,12); b = randint(2,12); a = ans*b; }
      current = { text: `${a} ${op} ${b} = ?`, ans };
      document.getElementById("q").textContent = current.text;

      const opts = new Set([ans]);
      while(opts.size<4){
        const delta = randint(1,10), sign = Math.random()<0.5?-1:1;
        opts.add(ans + sign*delta);
      }
      const shuffled = Array.from(opts).sort(()=>Math.random()-0.5);

      const box = document.getElementById("answers");
      box.innerHTML = "";
      shuffled.forEach(v=>{
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = v;
        btn.onclick = (e)=>choose(v, e.currentTarget);
        box.appendChild(btn);
      });
      flash("");
    }

    function choose(v, btnEl){
      if(!current) return;

      const eligible = canEarnAnother(); // check BEFORE incrementing

      if(Number(v)===current.ans){
        progress.correct++;
        if (eligible){
          pendingBalance += 10;
          flash("Correct! +10 coins (pending) ‚úÖ", true);
        } else {
          flash("Correct! (daily cap reached ‚Äî no coins added)", true);
        }
        tg.HapticFeedback?.notificationOccurred?.("success");
        applause();
        thumbs(btnEl);
        flyCoin(btnEl, document.getElementById("balance"));
      } else {
        progress.wrong++;
        flash(`Oops! Correct was ${current.ans}`, false);
        tg.HapticFeedback?.notificationOccurred?.("error");
        soundWrong();
        const r = btnEl.getBoundingClientRect();
        const pop = document.createElement('div');
        pop.className = 'pop'; pop.style.color = '#ff7a7a';
        pop.textContent = '‚úñ';
        pop.style.left = `${r.left + r.width/2}px`;
        pop.style.top  = `${r.top + r.height/2}px`;
        document.body.appendChild(pop);
        setTimeout(()=>pop.remove(), 900);
      }

      saveProgress();
      updateUI();
      updateBalanceDisplay();
      newQuestion(); // ‚úÖ always continue
    }

    /* ---------- Flying coin & +10 pop ---------- */
    function flyCoin(fromEl, toEl){
      const s = fromEl.getBoundingClientRect();
      const t = toEl.getBoundingClientRect();
      const coin = document.createElement('div');
      coin.className = 'coin';
      coin.style.left = `${s.left + s.width/2}px`;
      coin.style.top  = `${s.top  + s.height/2}px`;
      document.body.appendChild(coin);

      const dx = (t.left + t.width/2) - (s.left + s.width/2);
      const dy = (t.top  + 8) - (s.top + s.height/2);
      const start = performance.now(), dur = 620;
      const arc = Math.min(120, Math.max(60, Math.abs(dx)*0.2));
      (function anim(ts){
        const p = Math.min(1, (ts-start)/dur);
        const ease = 1 - Math.pow(1-p,3);
        const x = dx*ease;
        const y = dy*ease - arc*Math.sin(Math.PI*ease);
        const scale = 1 - 0.25*ease;
        const fade = 1 - 0.15*ease;
        coin.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        coin.style.opacity = String(fade);
        if(p<1) requestAnimationFrame(anim); else coin.remove();
      })(start);

      const pop = document.createElement('div');
      pop.className = 'pop';
      pop.textContent = '+10';
      pop.style.left = `${s.left + s.width/2}px`;
      pop.style.top  = `${s.top + s.height/2}px`;
      document.body.appendChild(pop);
      setTimeout(()=>pop.remove(), 900);
    }

    /* ---------- Fetch balance + today used from server ---------- */
    async function fetchBalanceAndToday() {
      try {
        const resp = await fetch("https://weks-bot.vercel.app/api/balance", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ initData: tg.initData || "" })
        });
        const data = await resp.json();
        if (data.ok) {
          serverBalance   = data.balance;
          serverTodayUsed = data.todayUsed || 0;

          // Clamp pending to remaining capacity from the server‚Äôs view
          const remainingFromServer = Math.max(0, DAILY_CAP - serverTodayUsed);
          const creditableCorrect = Math.min(progress.correct, remainingFromServer);
          pendingBalance  = creditableCorrect * 10;

          displayedBalance = serverBalance;
          document.getElementById("balance").textContent = `üí∞ Balance: ${displayedBalance}`;
          updateBalanceDisplay();
          updateUI();
        } else {
          document.getElementById("balance").textContent = "üí∞ Balance: error";
        }
      } catch {
        document.getElementById("balance").textContent = "üí∞ Balance: error";
      }
    }

    /* ---------- Claim ---------- */
    async function claim() {
      try {
        const resp = await fetch("https://weks-bot.vercel.app/api/claim", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            initData: tg.initData || "",
            correct: progress.correct,
            wrong: progress.wrong
          })
        });
        const data = await resp.json();
        if (!data.ok) { alertBox("Claim failed: " + (data.error || "Unknown error")); return; }

        if (data.message === "DAILY_CAP_REACHED") {
          alertBox(
            `üéâ You reached the daily cap of ${data.dailyCap}.\n` +
            `Keep practicing! Answers won‚Äôt add coins until tomorrow.\n\n` +
            `Balance: ${data.balance}`
          );
        } else {
          alertBox(
            `‚úÖ Claimed ${data.creditedCorrect} correct (+${data.coins} coins).\n` +
            `‚ùå Wrong: ${data.creditedWrong}\n` +
            `Today used: ${data.today}/${data.dailyCap}\n` +
            `Balance: ${data.balance}`
          );
          for(let i=0;i<4;i++){
            setTimeout(()=>{
              const fake = { getBoundingClientRect: ()=>({ left: innerWidth*(.2+.6*Math.random()), top: innerHeight-40, width:0, height:0 }) };
              flyCoin(fake, document.getElementById("balance"));
            }, i*120);
          }
        }

        // Sync with server truth
        serverBalance   = data.balance;
        serverTodayUsed = data.today;
        resetProgressForToday();
        updateUI();
        updateBalanceDisplay(true);

        setTimeout(()=>{ try { tg.close?.(); } catch {} }, 150);
      } catch (e) {
        console.error(e);
        alertBox("Could not send claim. Check your internet and try again.");
      }
    }
    document.getElementById("claim").onclick = claim;

    /* ---------- Actions (Invite / Leaderboard) ---------- */
    const inviteBtn = document.getElementById('inviteBtn');
    const leaderBtn = document.getElementById('leaderBtn');
    const botUsername = "WeksMathGameBot"; // <-- change if different

    inviteBtn.onclick = () => {
      // Build the same referral link your /invite uses
      const uid = tg.initDataUnsafe?.user?.id;
      const refLink = `https://t.me/${botUsername}${uid ? `?start=ref_${uid}` : ""}`;

      // 1) Ask the bot to generate the same message as /invite
      //    Your bot should handle web_app_data: {"type":"invite"} and reply with the invite text+link.
      try {
        tg.sendData(JSON.stringify({ type: "invite", link: refLink }));
        alertBox("üì® Check the chat ‚Äî your invite message is ready to forward.");
      } catch (e) {
        // 2) Fallback: open Telegram share sheet prefilled with the link and text
        const text = `üïπ Invite friends and earn +2,000 each!\nYour link: ${refLink}`;
        const share = `https://t.me/share/url?url=${encodeURIComponent(refLink)}&text=${encodeURIComponent(text)}`;
        try { tg.openTelegramLink(share); } catch { window.open(share, '_blank'); }
      }
    };

    leaderBtn.onclick = () => {
      const leaderboardURL = ""; // e.g., "https://weks-bot.vercel.app/leaderboard"
      if (!leaderboardURL) { alertBox("üèÜ Leaderboard is coming soon. Stay tuned!"); return; }
      try { tg.openLink(leaderboardURL); } catch { window.open(leaderboardURL, '_blank'); }
    };

    /* ---------- Mute toggle ---------- */
    const muteBtn = document.getElementById('muteBtn');
    muteBtn.addEventListener('click', () => { ctx(); AC.resume?.(); setMuted(!isMuted); });
    document.getElementById('muteBtn').textContent = isMuted ? "üîá" : "üîä";

    /* ---------- Init ---------- */
    fetchBalanceAndToday();
    newQuestion();
    updateUI();
  </script>
</body>
</html>
